/*
 * generated by Xtext 2.11.0
 */
package de.dlr.coredsl.tablegen

import java.io.File
import java.util.concurrent.Callable
import org.apache.log4j.Logger
import picocli.CommandLine.Parameters
import picocli.CommandLine.Option
import picocli.CommandLine
import com.google.inject.Inject
import com.google.inject.Provider
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.validation.IResourceValidator
import org.eclipse.xtext.generator.GeneratorDelegate
import org.eclipse.xtext.generator.JavaIoFileSystemAccess
import org.eclipse.emf.mwe.utils.ProjectMapping
import org.eclipse.emf.mwe.utils.StandaloneSetup
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.resource.XtextResource
import org.eclipse.emf.common.util.URI
import org.eclipse.xtext.util.CancelIndicator
import org.eclipse.xtext.validation.CheckMode
import org.eclipse.xtext.parser.ParseException
import org.eclipse.xtext.generator.GeneratorContext
import org.eclipse.xtext.generator.IFileSystemAccess
import java.lang.reflect.MalformedParametersException
import org.apache.log4j.Level
import org.eclipse.emf.ecore.resource.Resource

class Main implements Callable<Integer> {

    @Parameters(paramLabel="input_file", arity="1..*", description="one ore more files to process")
    public File[] files;

    @Option(names=#["-o", "--output-file"], description="output file")
    public File outputFile;

    @Option(names=#["-r", "--repository"], description="repository directory")
    public String repository = "";

    @Option(names=#["-v", "--verbose"], description="verbose output")
    public Boolean verbose = false;

    def static main(String[] args) {
        val ret = new CommandLine(new Main()).execute(args);
        System.exit(ret)
    }

    override Integer call() throws Exception {
        Logger.rootLogger.level = verbose?Level.DEBUG:Level.INFO
        val injector = new CoreDslGeneratorStandaloneSetup().createInjectorAndDoEMFRegistration
        injector.getInstance(GeneratorMain).run(this)
        return 0;
    }
}

class YAMLGeneratorContext extends GeneratorContext {
    public CompilerExtensionYAML yaml
}

class GeneratorMain {

    static val logger = Logger.getLogger(typeof(GeneratorMain));

    @Inject Provider<ResourceSet> resourceSetProvider

    @Inject IResourceValidator validator

    @Inject GeneratorDelegate generator

    @Inject JavaIoFileSystemAccess fsa

    def run(Main params) {
        if (params.repository.length > 0) {
            val projectMapping = new ProjectMapping
            projectMapping.projectName = "CoreDSL Repository"
            projectMapping.path = params.repository
            new StandaloneSetup().addProjectMapping(projectMapping)
        }
        try {
            val yaml = new CompilerExtensionYAML()
            for (file : params.files.filter[it.name.matches(".*\\.[yY][aA]?[mM][lL]$")]) {
                yaml.merge(CompilerExtensionYAML.parse(file))
                logger.info('Collected information from ' + file + '.')
            }
            for (file : params.files.filter[!it.name.matches(".*\\.[yY][aA]?[mM][lL]$")]) {
                // Load the resource
                val resourceSet = resourceSetProvider.get as XtextResourceSet
                resourceSet.addLoadOption(XtextResource.OPTION_RESOLVE_ALL, Boolean.TRUE);
                val resource = resourceSet.getResource(URI.createFileURI(file.absolutePath), true)
                // Validate the resource
                val issues = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl)
                if (!issues.empty) {
                    logger.error("Error validating " + resource.URI)
                    issues.forEach[logger.error(it)]
                    throw new ParseException("error validating " + resource.URI)
                }
                // Configure and start the generator
                resource.runGenerator(params.outputFile, yaml)
                logger.info('Code generation for ' + file + ' finished')
            }
        } catch (MalformedParametersException | IllegalArgumentException | ParseException e) {
            logger.error("Command line error " + e.message, e)
            return -1
        }
        return 0
    }
    
    def runGenerator(Resource resource, File outputFile, CompilerExtensionYAML yaml){
        if(outputFile !== null){
	        logger.info('Running generator to generate files in '+outputFile)
            fsa.outputPath = outputFile.absolutePath
        } else {
	        logger.info('Running generator to generate files')
            fsa.outputPath = './'
        }
        val outputCfg = fsa.outputConfigurations.get(IFileSystemAccess.DEFAULT_OUTPUT)
        outputCfg.setOverrideExistingResources(true)
        val context = new YAMLGeneratorContext => [cancelIndicator = CancelIndicator.NullImpl]
        context.yaml = yaml
        generator.doGenerate(resource, fsa, context)                
    }
}
